2110 >> 입력받은 배열을 sort하고 첫번째 원소를 시작점으로 잡은 후, low를 거리의 최솟값 1 high를 끝점과 첫점의 차잇값(최댓값)으로 설정한다
그 후 반복문을 돌면서 이전 공유기 설치지점과의 거리가 현재 mid값보다 큰 원소가 있다면 공유기를 설치한다.
그리고 공유기 설치지점 최신화.
반복문이 종료된 후 공유기의 갯수가 입력받은 최소 설치 갯수보다 크거나 같다면 충분하다는 뜻이므로 ans를 업데이트 하고
left를 mid로 준다
그렇지 않다면 right를 mid-1을 준다(mid거리만큼 공유기를 설치하는데에 실패했기때문) 

1300 >> low를 1 high를 n*n 으로 놓고 mid값을 계산해서 1~n행까지 mid값보다 작은 원소의 갯수를 count한다
cnt의 값이 원하는 k보다 크다면 mid값이 크다는 뜻이므로 high를 mid-1로 k보다 작다면 mid+1을 low로 설정한다
만약 같다면 mid가 ans가된다. 
이때 i행에서 mid값 보다 작은 원소의 갯수를 구하는 방법은
i행의 원소들은 i의 배수들이므로 mid를i로 나누면 mid가 i행의 몇번째 위치에 있는지 알수있게됨
ex) 3행에서 16의 위치는 16/3= 5임 실제로 3 6 9 12 15 16 즉 16보다 작은 놈이 5개임.

*** 12015 >> algorithm의 lower bound를 사용 lower는 target이상의 수를 찾고 그 수가있는 iterator를 반환, upper는 target보다 큰 애들 중 젤 처음 나온애 반환
코드를 보면 알겠지만 iter를 반환하니 *lower_bound(arr.begin(), arr.end(), input) = input;
이렇게 pointer로 직접 값을 할당시켜줌. 만약 input값이 iter와 같다면어차피 재할당하는 형식이기에 중복되지 않음
// 코드를 되게 깔끔하게 짤수있다!
