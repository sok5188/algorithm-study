11401 > 주어진 모듈러 연산값이 소수임 .. > 페르마 소정리를 이용해야 한다..
소수p 정수 a에 대해 a^(p-1)=1 (modp) 인데
여기서 a를 우항으로 넘가뿌면 a^(p-2)=a^-1 (mod p) 이게 곱셈의 역원일꺼임.. 수업시간에
그렇게 배운거같음
여튼
분자를 C 분모를 a라고하면  a^-1modp 는 a^(p-2) modp 와 같게됨
따라서 c/a modp는 c*a^-1 modp 이고 이는 c*a^(p-2) modp 와 같게됨
그러므로, a의 p-2승은 거듭제곱 분할정복으로 구하고 거기다가 c값 곱해주면 끝!

@@ 6549 >> stack을 이용해서 stack에 원소가 있고 stack에 top보다 ith height가 작다면 top에 해당하는
idx의 height 가진 놈을 이제 계산해줌 (더이상 해당 높이로 직사각형 만들 수 없음!)
뭐 그런식으로 반복해서 ans update ,, 여기서 idx0의 값은 0, 반복을 n항까지가 아니라 n+1항까지해줘야함 물론 n+1 항 높이 또한 0으로 해줘야함
차분히 생각? 해보면 이해하기 쉬울꺼..

@@ 11444 >> 엄청나게 큰 수도 long long으로 handling을 하지 못할 뿐 그냥 값 자체를 저장은 할수있는 것 같음..
해당 코드는 matrix를 2차원 벡터로 구현했고 피보나치 수열 을  행렬로 나타내어 보면
fn+2        (1  1)    fn+1
fn+1    =   (1  0)  X fn
의 형태로 나타낼 수 있고 이는 곧 (fn+1 fn   )   (1  1)^n 
                                (fn    fn-1)=   (1  0)    을 의미함.. 따라서 행렬의 제곱을 계산함으로써 해당 행렬의 원소 값을 알 수 있게되고 이를 통해 Fn을 얻을 수 있다.